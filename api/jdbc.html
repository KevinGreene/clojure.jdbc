<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>jdbc documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clojure.jdbc 0.2.0b2 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="jdbc.html"><span>jdbc</span></a></li><li><a href="jdbc.constants.html"><span>jdbc.constants</span></a></li><li><a href="jdbc.pool.html"><span>jdbc.pool</span></a></li><li><a href="jdbc.transaction.html"><span>jdbc.transaction</span></a></li><li><a href="jdbc.types.html"><span>jdbc.types</span></a></li><li><a href="jdbc.types.connection.html"><span>jdbc.types.connection</span></a></li><li><a href="jdbc.types.resultset.html"><span>jdbc.types.resultset</span></a></li><li><a href="jdbc.util.html"><span>jdbc.util</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="jdbc.html#var-execute%21"><span>execute!</span></a></li><li><a href="jdbc.html#var-execute-prepared%21"><span>execute-prepared!</span></a></li><li><a href="jdbc.html#var-execute-statement%21"><span>execute-statement!</span></a></li><li><a href="jdbc.html#var-get-returning-records"><span>get-returning-records</span></a></li><li><a href="jdbc.html#var-is-prepared-statement%3F"><span>is-prepared-statement?</span></a></li><li><a href="jdbc.html#var-make-connection"><span>make-connection</span></a></li><li><a href="jdbc.html#var-make-prepared-statement"><span>make-prepared-statement</span></a></li><li><a href="jdbc.html#var-make-query"><span>make-query</span></a></li><li><a href="jdbc.html#var-map-%3Eproperties"><span>map-&gt;properties</span></a></li><li><a href="jdbc.html#var-query"><span>query</span></a></li><li><a href="jdbc.html#var-query-first"><span>query-first</span></a></li><li><a href="jdbc.html#var-result-set-%3Elazyseq"><span>result-set-&gt;lazyseq</span></a></li><li><a href="jdbc.html#var-result-set-%3Evector"><span>result-set-&gt;vector</span></a></li><li><a href="jdbc.html#var-uri-%3Edbspec"><span>uri-&gt;dbspec</span></a></li><li><a href="jdbc.html#var-with-connection"><span>with-connection</span></a></li><li><a href="jdbc.html#var-with-query"><span>with-query</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>jdbc documentation</h2><pre class="doc">Alternative implementation of jdbc wrapper for clojure.
</pre><div class="public" id="var-execute%21"><h3>execute!</h3><div class="usage"><code>(execute! conn &amp; commands)</code></div><pre class="doc">Run arbitrary number of raw sql commands such as: CREATE TABLE,
DROP TABLE, etc... If your want transactions, you can wrap this
call in transaction using `with-transaction` context block macro
that is available in  ``jdbc.transaction`` namespace.

Warning: not all database servers support ddl in transactions.

Examples:

  ;; Without transactions
  (with-connection dbspec conn
    (execute! conn 'CREATE TABLE foo (id serial, name text);'))

  ;; In one transaction
  (with-connection dbspec conn
    (tx/with-transaction conn
      (execute! conn 'CREATE TABLE foo (id serial, name text);')))
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L229">Source</a></div></div><div class="public" id="var-execute-prepared%21"><h3>execute-prepared!</h3><div class="usage"><code>(execute-prepared! conn sql &amp; param-groups)</code></div><pre class="doc">Given a active connection and sql (or prepared statement),
executes a query in a database. This differs from `execute!` function
with that this function allows pass parameters to query in a more safe
way and permit pass group of parrams enabling bulk operations.

After connection, sql/prepared statement and any number of group of
params you can pass options map (same as on `make-prepared-statement`
function).

Note: Some options are incompatible with self defined prepared
statement.

Example:

(with-connection dbspec conn
  (let [sql &quot;UPDATE TABLE foo SET x = ? WHERE y = ?;&quot;]
    (execute-prepared! conn sql [1 2] [2 3] [3 4])))</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L313">Source</a></div></div><div class="public" id="var-execute-statement%21"><h3>execute-statement!</h3><div class="usage"><code>(execute-statement! conn stmt param-groups)</code></div><pre class="doc">Given a connection statement and paramgroups (can be empty)
execute the prepared statement and return results from it.

This is a low level interface and should be used with precaution. This
function is used internally for execue raw sql such as CREATE/DROP
table.

Status: Alpha - Implementation and name of this method can change on
next versions.</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L110">Source</a></div></div><div class="public" id="var-get-returning-records"><h3>get-returning-records</h3><div class="usage"><code>(get-returning-records conn stmt)</code></div><pre class="doc">Given a executed prepared statement with expected returning
values. Return a vector of records of returning values.
Usually is a id of just inserted objects, but in other cases
can be complete objects.</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L256">Source</a></div></div><div class="public" id="var-is-prepared-statement%3F"><h3>is-prepared-statement?</h3><div class="usage"><code>(is-prepared-statement? obj)</code></div><pre class="doc">Check if specified object is prepared statement.
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L266">Source</a></div></div><div class="public" id="var-make-connection"><h3>make-connection</h3><div class="usage"><code>(make-connection {:keys [isolation-level schema read-only], :or {read-only false, schema nil}, :as dbspec})</code></div><pre class="doc">Creates a connection to a database from dbspec, and dbspec
can be:

- map containing connection parameter
- map containing a datasource
- URI or string

The dbspec map has this possible variants:

Classic approach:
  :subprotocol -&gt; (required) string that represents a vendor name (ex: postgresql)
  :subname -&gt; (required) string that represents a database name (ex: test)
  :classname -&gt; (optional) string that represents a class name.
  (many others options that are pased directly as driver parameters)

Pretty format:
  :vendor -&gt; (required) string that represents a vendor name (ex: postgresql)
  :name -&gt; (required) string that represents a database name (ex: test)
  :host -&gt; (optional) string that represents a database hostname (default: 127.0.0.1)
  :port -&gt; (optional) long number that represents a database port (default: driver default)
  (many others options that are pased directly as driver parameters)

Raw format:
  :connection-uri -&gt; String that passed directly to DriverManager/getConnection

URI or String format:
  vendor://user:password@host:post/dbname

Additional options for map based dbspecs:
  :schema -&gt; string that represents a schema name (default: nil)
  :read-only -&gt; boolean for mark entire connection read only.

For more details, see documentation.</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L182">Source</a></div></div><div class="public" id="var-make-prepared-statement"><h3>make-prepared-statement</h3><div class="usage"><code>(make-prepared-statement conn sqlvec)</code><code>(make-prepared-statement conn sqlvec {:keys [result-type result-concurency fetch-size max-rows holdability lazy returning], :or {result-type :forward-only, result-concurency :read-only, fetch-size 100}, :as options})</code></div><pre class="doc">Given connection and query, return a prepared statement.
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L271">Source</a></div></div><div class="public" id="var-make-query"><h3>make-query</h3><div class="usage"><code>(make-query conn sql-with-params)</code><code>(make-query conn sql-with-params {:keys [fetch-size lazy], :or {lazy false}, :as options})</code></div><pre class="doc">Given a connection and paramatrized sql, execute a query and
return a instance of ResultSet that works as stantard clojure
map but implements a closable interface.

A returned ``jdbc.types.resultset.ResultSet`` works as a wrapper
around a prepared statement and java.sql.ResultSet mostly used for
server side cursors properly resource management.

This functions indents be a low level access for making queries
and it delegate to a user the resource management.

NOTE: It strongly recommended not use this function directly and use a ``with-query``
macro for make query thar returns large amount of data or simple ``query`` function
that returns directly a evaluated result.

Example using parametrized sql:

  (with-open [result (make-query conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (doseq [row (:data result)]
      (println row)))

Example using plain sql (without parameters):

  (with-open [result (make-query conn &quot;SELECT version();&quot;)]
    (doseq [row (:data result)]
      (println row)))

Example using extern prepared statement:

  (let [stmt (make-prepared-statement conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (with-open [result (make-query conn stmt)]
      (doseq [row (:data result)]
        (println row))))</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L376">Source</a></div></div><div class="public" id="var-map-%3Eproperties"><h3>map-&gt;properties</h3><div class="usage"><code>(map-&gt;properties data)</code></div><pre class="doc">Convert hash-map to java.utils.Properties instance. This method is used
internally for convert dbspec map to properties instance, but it can
be usefull for other purposes.
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L34">Source</a></div></div><div class="public" id="var-query"><h3>query</h3><div class="usage"><code>(query conn sqlvec)</code><code>(query conn sqlvec {:keys [lazy], :or {lazy false}, :as options})</code></div><pre class="doc">Perform a simple sql query and return a evaluated result as vector.

``sqlvec`` parameter can be: parametrized sql (vector format), plain sql
(simple sql string) or prepared statement instance.

Example using parametrized sql:

  (doseq [row (query conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (println row))

Example using plain sql (without parameters):

  (doseq [row (query conn &quot;SELECT version();&quot;)]
    (println row))

Example using extern prepared statement:

  (let [stmt (make-prepared-statement conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (doseq [row (query conn stmt)]
      (println row)))
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L419">Source</a></div></div><div class="public" id="var-query-first"><h3>query-first</h3><div class="usage"></div><pre class="doc">Perform a simple sql query and return the first result. It accepts the
same arguments as the ``query`` function.</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L448">Source</a></div></div><div class="public" id="var-result-set-%3Elazyseq"><h3>result-set-&gt;lazyseq</h3><div class="usage"><code>(result-set-&gt;lazyseq conn rs &amp; [{:keys [identifiers as-rows?], :or {identifiers str/lower-case, as-rows? false}, :as options}])</code></div><pre class="doc">Function that wraps result in a lazy seq. This function
is part of public api but can not be used directly (you should pass
this function as parameter to `query` function).

Required parameters:
  rs: ResultSet instance.

Optional named parameters:
  :identifiers -&gt; function that is applied for column name
                  when as-arrays? is false
  :as-rows?    -&gt; by default this function return a lazy seq of
                  records (map), but in certain circumstances you
                  need results as a lazy-seq of vectors. With this keywork
                  parameter you can enable this behavior and return a lazy-seq
                  of vectors instead of records (maps).
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L70">Source</a></div></div><div class="public" id="var-result-set-%3Evector"><h3>result-set-&gt;vector</h3><div class="usage"><code>(result-set-&gt;vector &amp; args)</code></div><pre class="doc">Function that evaluates a result into one clojure persistent
vector. Accept same parameters as `result-set-&gt;lazyseq`.</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L104">Source</a></div></div><div class="public" id="var-uri-%3Edbspec"><h3>uri-&gt;dbspec</h3><div class="usage"><code>(uri-&gt;dbspec url)</code></div><pre class="doc">Parses a dbspec as uri into a plain dbspec. This function
accepts ``java.net.URI`` or ``String`` as parameter.</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L50">Source</a></div></div><div class="public" id="var-with-connection"><h3>with-connection</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-connection dbspec &amp; body)</code></div><pre class="doc">Given database connection paramers (dbspec), creates
a context with new connection to database that are closed
at end of code block.

If dbspec has datasource (connection pool), instead of create
a new connection, get it from connection pool and release it
at the end.

Example:

  (with-connection [conn dbspec]
    (do-somethin-with-connection conn))

Deprecated but yet working example (this behavior should be
removed on 1.1 version):

  (with-connection dbspec conn
    (do-something-with conn))
  </pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L474">Source</a></div></div><div class="public" id="var-with-query"><h3>with-query</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-query conn bindname sqlvec &amp; body)</code></div><pre class="doc">Idiomatic dsl macro for ``query`` function that handles well queries
what returns a huge amount of results.

``sqlvec`` can be in same formats as in ``query`` function.

NOTE: This method ensueres a query in one implicit transaction.

Example:

  (with-query conn results
    [&quot;SELECT name FROM people WHERE id = ?&quot; 1]
    (doseq [row results]
      (println row)))
</pre><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc.clj#L453">Source</a></div></div></div></body></html>
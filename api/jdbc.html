<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>jdbc documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clj.jdbc 0.1.0-beta1 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><span>Namespaces</span></h3><ul><li class="current"><a href="jdbc.html"><span>jdbc</span></a></li><li><a href="jdbc.pool.html"><span>jdbc.pool</span></a></li><li><a href="jdbc.pool.c3p0.html"><span>jdbc.pool.c3p0</span></a></li><li><a href="jdbc.sql.html"><span>jdbc.sql</span></a></li></ul></div><div class="sidebar" id="vars"><h3>Public Vars</h3><ul><li><a href="jdbc.html#var-*default-isolation-level*"><span>*default-isolation-level*</span></a></li><li><a href="jdbc.html#var-call-in-transaction"><span>call-in-transaction</span></a></li><li><a href="jdbc.html#var-execute%21"><span>execute!</span></a></li><li><a href="jdbc.html#var-execute-prepared%21"><span>execute-prepared!</span></a></li><li><a href="jdbc.html#var-is-rollback-only%3F"><span>is-rollback-only?</span></a></li><li><a href="jdbc.html#var-make-connection"><span>make-connection</span></a></li><li><a href="jdbc.html#var-make-prepared-statement"><span>make-prepared-statement</span></a></li><li><a href="jdbc.html#var-make-query"><span>make-query</span></a></li><li><a href="jdbc.html#var-mark-as-rollback-only%21"><span>mark-as-rollback-only!</span></a></li><li><a href="jdbc.html#var-parse-properties-uri"><span>parse-properties-uri</span></a></li><li><a href="jdbc.html#var-result-set-lazyseq"><span>result-set-lazyseq</span></a></li><li><a href="jdbc.html#var-result-set-vec"><span>result-set-vec</span></a></li><li><a href="jdbc.html#var-set-default-isolation-level%21"><span>set-default-isolation-level!</span></a></li><li><a href="jdbc.html#var-strip-jdbc"><span>strip-jdbc</span></a></li><li><a href="jdbc.html#var-unmark-rollback-only%21"><span>unmark-rollback-only!</span></a></li><li><a href="jdbc.html#var-with-connection"><span>with-connection</span></a></li><li><a href="jdbc.html#var-with-query"><span>with-query</span></a></li><li><a href="jdbc.html#var-with-transaction"><span>with-transaction</span></a></li></ul></div><div class="namespace-docs" id="content"><h2>jdbc documentation</h2><pre class="doc">Alternative implementation of jdbc wrapper for clojure.
</pre><div class="public" id="var-*default-isolation-level*"><h3>*default-isolation-level*</h3><div class="usage"></div><pre class="doc"></pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L27">Source</a></div></div><div class="public" id="var-call-in-transaction"><h3>call-in-transaction</h3><div class="usage"><code>(call-in-transaction conn func &amp; {:keys [savepoints], :or {savepoints true}, :as opts})</code></div><pre class="doc">Wrap function in one transaction. If current connection is already in
transaction, it uses truly nested transactions for properly handle it.
The availability of this feature depends on database support for it.

Example:

(with-connection dbspec conn
  (call-in-transaction conn (fn [] (execute! conn 'DROP TABLE foo;'))))

For more idiomatic code, you should use `with-transaction` macro.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L294">Source</a></div></div><div class="public" id="var-execute%21"><h3>execute!</h3><div class="usage"><code>(execute! conn &amp; commands)</code></div><pre class="doc">Run arbitrary number of raw sql commands such as: CREATE TABLE,
DROP TABLE, etc... If your want transactions, you can wrap this
call in transaction using `with-transaction` context block macro.

Warning: not all database servers support ddl in transactions.

Examples:

  ;; Without transactions
  (with-connection dbspec conn
    (execute! conn 'CREATE TABLE foo (id serial, name text);'))

  ;; In one transaction
  (with-connection dbspec conn
    (with-transaction conn
      (execute! conn 'CREATE TABLE foo (id serial, name text);')))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L352">Source</a></div></div><div class="public" id="var-execute-prepared%21"><h3>execute-prepared!</h3><div class="usage"><code>(execute-prepared! conn sql &amp; param-groups)</code></div><pre class="doc">Same as `execute!` function, but works with prepared statements
instead with raw sql.

With this you can execute multiple operations throught
one call.

Example:

  (with-connection dbspec conn
    (let [sql 'UPDATE TABLE foo SET x = ? WHERE y = ?;']
      (execute-prepared! conn sql [1 2] [2 3] [3 4])))

  This code should send this sql sentences:

    UPDATE TABLE foo SET x = 1 WHERE y = 2;
    UPDATE TABLE foo SET x = 2 WHERE y = 3;
    UPDATE TABLE foo SET x = 3 WHERE y = 4;
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L378">Source</a></div></div><div class="public" id="var-is-rollback-only%3F"><h3>is-rollback-only?</h3><div class="usage"><code>(is-rollback-only? conn)</code></div><pre class="doc">Check if a `:rollback-only` flag is set on the
current connection.</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L287">Source</a></div></div><div class="public" id="var-make-connection"><h3>make-connection</h3><div class="usage"><code>(make-connection dbspec)</code></div><pre class="doc">Creates a connection to a database. db-spec is a map containing connection
parameters. db-spec is a map containing values for one of the following
parameter sets:

Factory:
  :factory     (required) a function of one argument, a map of params
  (others)     (optional) passed to the factory function in a map

DriverManager:
  :subprotocol (required) a String, the jdbc subprotocol
  :subname     (required) a String, the jdbc subname
  :classname   (optional) a String, the jdbc driver class name
  (others)     (optional) passed to the driver as properties.

DataSource:
  :datasource  (required) a javax.sql.DataSource
  :username    (optional) a String
  :password    (optional) a String, required if :username is supplied

JNDI:
  Not supported because it's shit!

Raw:
  :connection-uri (required) a String
               Passed directly to DriverManager/getConnection

URI:
  Parsed JDBC connection string - see below

String:
  subprotocol://user:password@host:port/subname
               An optional prefix of jdbc: is allowed.</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L205">Source</a></div></div><div class="public" id="var-make-prepared-statement"><h3>make-prepared-statement</h3><div class="usage"><code>(make-prepared-statement conn sqlvec)</code></div><pre class="doc">Given connection and parametrized query as vector with first
argument as string and other arguments as params, return a
prepared statement.

Example:

  (let [stmt (make-prepared-statement conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (println (instance? java.sql.PreparedStatement stmt)))
  ;; -&gt; true
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L167">Source</a></div></div><div class="public" id="var-make-query"><h3>make-query</h3><div class="usage"><code>(make-query conn sql-with-params &amp; {:keys [lazy?], :or {lazy? false}, :as options})</code></div><pre class="doc">Given a connection and paramatrized sql, execute a query and
return a instance of QueryResult that works as stantard clojure
map but implements a closable interface.

This functions indents be a low level access for making queries
and it delegate to a user the resource management. You should
use `with-open` macro for store a result as example:

  (with-open [result (make-query conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (doseq [row (:data result)]
      (println row)))

A QueryResult contains a these keys:

- `:stmt` as PreparedStatement instance
- `:rs` as ResultSet instance
- `:data` as lazy seq of results.

You can pass options on call `make-query` for make `:data` key as
evaluated (not lazy) instead of lazy sequence:

  (with-open [result (make-query conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1] {:lazy? false})]
    (doseq [row (:data result)]
      (println row)))

NOTE: It strongly recommended not use this function directly and use a `with-query`
macro that manage resources for you and return directly a seq instead of a
QueryResult instance.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L447">Source</a></div></div><div class="public" id="var-mark-as-rollback-only%21"><h3>mark-as-rollback-only!</h3><div class="usage"><code>(mark-as-rollback-only! conn)</code></div><pre class="doc">Mark a current connection with `:rollback-only` flag.

If a code runs inside a transaction, this ensures that on
the successful end of execution of your code executes rollback
instead of commit.

Example:

  (with-transaction conn
    (make-some-queries-without-changes conn)
    (mark-as-rollback-only! conn))

</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L263">Source</a></div></div><div class="public" id="var-parse-properties-uri"><h3>parse-properties-uri</h3><div class="usage"><code>(parse-properties-uri uri)</code></div><pre class="doc"></pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L102">Source</a></div></div><div class="public" id="var-result-set-lazyseq"><h3>result-set-lazyseq</h3><div class="usage"><code>(result-set-lazyseq rs &amp; {:keys [identifiers as-arrays?], :or {identifiers str/lower-case, as-arrays? false}})</code></div><pre class="doc">Function that wraps result in a lazy seq. This function
is part of public api but can not be used directly (you should pass
this function as parameter to `query` function).

Required parameters:
  rs: ResultSet instance.

Optional named parameters:
  :identifiers -&gt; function that is applied for column name
                  when as-arrays? is false
  :as-arrays?  -&gt; by default this function return a lazy seq of
                  records as map, but in certain circumstances you
                  need results as array. With this keywork parameter
                  you can set result as array instead map record.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L406">Source</a></div></div><div class="public" id="var-result-set-vec"><h3>result-set-vec</h3><div class="usage"><code>(result-set-vec &amp; args)</code></div><pre class="doc">Function that evaluates a result into one clojure persistent
vector. Accept same parameters as `result-set-lazyseq`.</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L441">Source</a></div></div><div class="public" id="var-set-default-isolation-level%21"><h3>set-default-isolation-level!</h3><div class="usage"><code>(set-default-isolation-level! level)</code></div><pre class="doc">Set a default isolation level for each new
created connection.

By default no isolation level is set.

You can obtain a current default isolation level with:

  (deref *default-isolation-level*)
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L33">Source</a></div></div><div class="public" id="var-strip-jdbc"><h3>strip-jdbc</h3><div class="usage"><code>(strip-jdbc spec)</code></div><pre class="doc"></pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L95">Source</a></div></div><div class="public" id="var-unmark-rollback-only%21"><h3>unmark-rollback-only!</h3><div class="usage"><code>(unmark-rollback-only! conn)</code></div><pre class="doc">Revert flag setted by `mark-as-rollback-only!`.
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L281">Source</a></div></div><div class="public" id="var-with-connection"><h3>with-connection</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-connection dbspec bindname &amp; body)</code></div><pre class="doc">Given database connection paramers (dbspec), creates
a context with new connection to database that are closed
at end of code block.

If dbspec has datasource (connection pool), instead of create
a new connection, get it from connection pool and release it
at the end.

Example:

  (with-connection dbspec conn
    (do-something-with conn))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L245">Source</a></div></div><div class="public" id="var-with-query"><h3>with-query</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-query conn bindname sql-with-params &amp; body)</code></div><pre class="doc">Idiomatic dsl macro for `query` function that automatically closes
all resources when context is reached.

Example:

  (with-query conn results
    ['SELECT name FROM people WHERE id = ?' [1]]
    (doseq [row results]
      (println row)))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L496">Source</a></div></div><div class="public" id="var-with-transaction"><h3>with-transaction</h3><h4 class="macro">macro</h4><div class="usage"><code>(with-transaction conn &amp; body)</code></div><pre class="doc">Creates a context that evaluates in transaction (or nested transaction).

This is a more idiomatic way to execute some database operations in
atomic way.

Example:

  (with-transaction conn
    (execute! conn 'DROP TABLE foo;')
    (execute! conn 'DROP TABLE bar;'))
</pre><div class="src-link"><a href="http://github.com/niwibe/clj.jdbc/blob/master/src/jdbc.clj#L336">Source</a></div></div></div></body></html>
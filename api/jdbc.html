<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>jdbc documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clojure.jdbc 0.3.2 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1 current"><a href="jdbc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jdbc</span></div></a></li><li class="depth-2 branch"><a href="jdbc.constants.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>constants</span></div></a></li><li class="depth-2 branch"><a href="jdbc.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="jdbc.impl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></a></li><li class="depth-2 branch"><a href="jdbc.meta.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>meta</span></div></a></li><li class="depth-2 branch"><a href="jdbc.proto.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proto</span></div></a></li><li class="depth-2 branch"><a href="jdbc.transaction.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transaction</span></div></a></li><li class="depth-2 branch"><a href="jdbc.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2"><a href="jdbc.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="jdbc.html#var-execute.21"><div class="inner"><span>execute!</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-execute-prepared.21"><div class="inner"><span>execute-prepared!</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-execute-statement.21"><div class="inner"><span>execute-statement!</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-get-returning-records"><div class="inner"><span>get-returning-records</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-is-prepared-statement.3F"><div class="inner"><span>is-prepared-statement?</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-make-connection"><div class="inner"><span>make-connection</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-make-query"><div class="inner"><span>make-query</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-map-.3Eproperties"><div class="inner"><span>map-&gt;properties</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-query"><div class="inner"><span>query</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-query-first"><div class="inner"><span>query-first</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-result-set-.3Elazyseq"><div class="inner"><span>result-set-&gt;lazyseq</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-result-set-.3Evector"><div class="inner"><span>result-set-&gt;vector</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-uri-.3Edbspec"><div class="inner"><span>uri-&gt;dbspec</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-with-connection"><div class="inner"><span>with-connection</span></div></a></li><li class="depth-1"><a href="jdbc.html#var-with-query"><div class="inner"><span>with-query</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">jdbc</h2><div class="doc"><pre class="plaintext">Alternative implementation of jdbc wrapper for clojure.
</pre></div><div class="public anchor" id="var-execute.21"><h3>execute!</h3><div class="usage"><code>(execute! conn &amp; commands)</code></div><div class="doc"><pre class="plaintext">Run arbitrary number of raw sql commands such as: CREATE TABLE,
DROP TABLE, etc... If your want transactions, you can wrap this
call in transaction using `with-transaction` context block macro
that is available in  `jdbc.transaction` namespace.

Warning: not all database servers support ddl in transactions.

Examples:

  ;; Without transactions
  (with-connection dbspec conn
    (execute! conn &apos;CREATE TABLE foo (id serial, name text);&apos;))

  ;; In one transaction
  (with-connection dbspec conn
    (tx/with-transaction conn
      (execute! conn &apos;CREATE TABLE foo (id serial, name text);&apos;)))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L232">view source</a></div></div><div class="public anchor" id="var-execute-prepared.21"><h3>execute-prepared!</h3><div class="usage"><code>(execute-prepared! conn sql &amp; param-groups)</code></div><div class="doc"><pre class="plaintext">Given a active connection and sql (or prepared statement),
executes a query in a database. This differs from `execute!` function
with that this function allows pass parameters to query in a more safe
way and permit pass group of parrams enabling bulk operations.

After connection, sql/prepared statement and any number of group of
params you can pass options map (same as on `make-prepared-statement`
function).

Note: Some options are incompatible with self defined prepared
statement.

Example:

(with-connection dbspec conn
  (let [sql &quot;UPDATE TABLE foo SET x = ? WHERE y = ?;&quot;]
    (execute-prepared! conn sql [1 2] [2 3] [3 4])))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L272">view source</a></div></div><div class="public anchor" id="var-execute-statement.21"><h3>execute-statement!</h3><div class="usage"><code>(execute-statement! conn stmt param-groups)</code></div><div class="doc"><pre class="plaintext">Given a connection statement and paramgroups (can be empty)
execute the prepared statement and return results from it.

This is a low level interface and should be used with precaution. This
function is used internally for execue raw sql such as CREATE/DROP
table.

Status: Alpha - Implementation and name of this method can change on
next versions.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L116">view source</a></div></div><div class="public anchor" id="var-get-returning-records"><h3>get-returning-records</h3><div class="usage"><code>(get-returning-records conn stmt)</code></div><div class="doc"><pre class="plaintext">Given a executed prepared statement with expected returning
values. Return a vector of records of returning values.
Usually is a id of just inserted objects, but in other cases
can be complete objects.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L258">view source</a></div></div><div class="public anchor" id="var-is-prepared-statement.3F"><h3>is-prepared-statement?</h3><div class="usage"><code>(is-prepared-statement? obj)</code></div><div class="doc"><pre class="plaintext">Check if specified object is prepared statement.
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L267">view source</a></div></div><div class="public anchor" id="var-make-connection"><h3>make-connection</h3><div class="usage"><code>(make-connection {:keys [isolation-level schema read-only], :or {read-only false, schema nil}, :as dbspec})</code></div><div class="doc"><pre class="plaintext">Creates a connection to a database from dbspec, and dbspec
can be:

- map containing connection parameter
- map containing a datasource
- URI or string

The dbspec map has this possible variants:

Classic approach:
  :subprotocol -&gt; (required) string that represents a vendor name (ex: postgresql)
  :subname -&gt; (required) string that represents a database name (ex: test)
  :classname -&gt; (optional) string that represents a class name.
  (many others options that are pased directly as driver parameters)

Pretty format:
  :vendor -&gt; (required) string that represents a vendor name (ex: postgresql)
  :name -&gt; (required) string that represents a database name (ex: test)
  :host -&gt; (optional) string that represents a database hostname (default: 127.0.0.1)
  :port -&gt; (optional) long number that represents a database port (default: driver default)
  (many others options that are pased directly as driver parameters)

Raw format:
  :connection-uri -&gt; String that passed directly to DriverManager/getConnection

URI or String format:
  vendor://user:password@host:post/dbname

Additional options for map based dbspecs:
  :schema -&gt; string that represents a schema name (default: nil)
  :read-only -&gt; boolean for mark entire connection read only.

For more details, see documentation.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L184">view source</a></div></div><div class="public anchor" id="var-make-query"><h3>make-query</h3><div class="usage"><code>(make-query conn sql-with-params)</code><code>(make-query conn sql-with-params {:keys [fetch-size lazy], :or {lazy false}, :as options})</code></div><div class="doc"><pre class="plaintext">Given a connection and paramatrized sql, execute a query and
return a instance of ResultSet that works as stantard clojure
map but implements a closable interface.

A returned `jdbc.types.ResultSet` works as a wrapper
around a prepared statement and java.sql.ResultSet mostly used for
server side cursors properly resource management.

This functions indents be a low level access for making queries
and it delegate to a user the resource management.

NOTE: It strongly recommended not use this function directly and use a `with-query`
macro for make query thar returns large amount of data or simple `query` function
that returns directly a evaluated result.

Example using parametrized sql:

  (with-open [result (make-query conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (doseq [row (:data result)]
      (println row)))

Example using plain sql (without parameters):

  (with-open [result (make-query conn &quot;SELECT version();&quot;)]
    (doseq [row (:data result)]
      (println row)))

Example using extern prepared statement:

  (let [stmt (make-prepared-statement conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (with-open [result (make-query conn stmt)]
      (doseq [row (:data result)]
        (println row))))</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L326">view source</a></div></div><div class="public anchor" id="var-map-.3Eproperties"><h3>map-&gt;properties</h3><div class="usage"><code>(map-&gt;properties data)</code></div><div class="doc"><pre class="plaintext">Convert hash-map to java.utils.Properties instance. This method is used
internally for convert dbspec map to properties instance, but it can
be usefull for other purposes.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L31">view source</a></div></div><div class="public anchor" id="var-query"><h3>query</h3><div class="usage"><code>(query conn sqlvec)</code><code>(query conn sqlvec {:keys [lazy], :or {lazy false}, :as options})</code></div><div class="doc"><pre class="plaintext">Perform a simple sql query and return a evaluated result as vector.

`sqlvec` parameter can be: parametrized sql (vector format), plain sql
(simple sql string) or prepared statement instance.

Example using parametrized sql:

  (doseq [row (query conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (println row))

Example using plain sql (without parameters):

  (doseq [row (query conn &quot;SELECT version();&quot;)]
    (println row))

Example using extern prepared statement:

  (let [stmt (make-prepared-statement conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (doseq [row (query conn stmt)]
      (println row)))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L368">view source</a></div></div><div class="public anchor" id="var-query-first"><h3>query-first</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Perform a simple sql query and return the first result. It accepts the
same arguments as the `query` function.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L396">view source</a></div></div><div class="public anchor" id="var-result-set-.3Elazyseq"><h3>result-set-&gt;lazyseq</h3><div class="usage"><code>(result-set-&gt;lazyseq conn rs &amp; [{:keys [identifiers as-rows?], :or {identifiers str/lower-case, as-rows? false}, :as options}])</code></div><div class="doc"><pre class="plaintext">Function that wraps result in a lazy seq. This function
is part of public api but can not be used directly (you should pass
this function as parameter to `query` function).

Required parameters:
  rs: ResultSet instance.

Optional named parameters:
  :identifiers -&gt; function that is applied for column name
                  when as-arrays? is false
  :as-rows?    -&gt; by default this function return a lazy seq of
                  records (map), but in certain circumstances you
                  need results as a lazy-seq of vectors. With this keywork
                  parameter you can enable this behavior and return a lazy-seq
                  of vectors instead of records (maps).
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L76">view source</a></div></div><div class="public anchor" id="var-result-set-.3Evector"><h3>result-set-&gt;vector</h3><div class="usage"><code>(result-set-&gt;vector &amp; args)</code></div><div class="doc"><pre class="plaintext">Function that evaluates a result into one clojure persistent
vector. Accept same parameters as `result-set-&gt;lazyseq`.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L110">view source</a></div></div><div class="public anchor" id="var-uri-.3Edbspec"><h3>uri-&gt;dbspec</h3><div class="usage"><code>(uri-&gt;dbspec url)</code></div><div class="doc"><pre class="plaintext">Parses a dbspec as uri into a plain dbspec. This function
accepts `java.net.URI` or `String` as parameter.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L55">view source</a></div></div><div class="public anchor" id="var-with-connection"><h3>with-connection</h3><h4 class="type">macro</h4><div class="usage"><code>(with-connection dbspec &amp; body)</code></div><div class="doc"><pre class="plaintext">Given database connection paramers (dbspec), creates
a context with new connection to database that are closed
at end of code block.

If dbspec has datasource (connection pool), instead of create
a new connection, get it from connection pool and release it
at the end.

Example:

  (with-connection [conn dbspec]
    (do-somethin-with-connection conn))

Deprecated but yet working example (this behavior should be
removed on 1.1 version):

  (with-connection dbspec conn
    (do-something-with conn))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L422">view source</a></div></div><div class="public anchor" id="var-with-query"><h3>with-query</h3><h4 class="type">macro</h4><div class="usage"><code>(with-query conn bindname sqlvec &amp; body)</code></div><div class="doc"><pre class="plaintext">Idiomatic dsl macro for `query` function that handles well queries
what returns a huge amount of results.

`sqlvec` can be in same formats as in `query` function.

NOTE: This method ensueres a query in one implicit transaction.

Example:

  (with-query conn results
    [&quot;SELECT name FROM people WHERE id = ?&quot; 1]
    (doseq [row results]
      (println row)))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L401">view source</a></div></div></div></body></html>
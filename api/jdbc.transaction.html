<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>jdbc.transaction documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clojure.jdbc 0.3.2 API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><a href="jdbc.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jdbc</span></div></a></li><li class="depth-2 branch"><a href="jdbc.constants.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>constants</span></div></a></li><li class="depth-2 branch"><a href="jdbc.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="jdbc.impl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></a></li><li class="depth-2 branch"><a href="jdbc.meta.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>meta</span></div></a></li><li class="depth-2 branch"><a href="jdbc.proto.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proto</span></div></a></li><li class="depth-2 branch current"><a href="jdbc.transaction.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transaction</span></div></a></li><li class="depth-2 branch"><a href="jdbc.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2"><a href="jdbc.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="jdbc.transaction.html#var-*default-tx-strategy*"><div class="inner"><span>*default-tx-strategy*</span></div></a></li><li class="depth-1"><a href="jdbc.transaction.html#var--.3EDefaultTransactionStrategy"><div class="inner"><span>-&gt;DefaultTransactionStrategy</span></div></a></li><li class="depth-1"><a href="jdbc.transaction.html#var-call-in-transaction"><div class="inner"><span>call-in-transaction</span></div></a></li><li class="depth-1"><a href="jdbc.transaction.html#var-is-rollback-set.3F"><div class="inner"><span>is-rollback-set?</span></div></a></li><li class="depth-1"><a href="jdbc.transaction.html#var-ITransactionStrategy"><div class="inner"><span>ITransactionStrategy</span></div></a></li><li class="depth-2 branch"><a href="jdbc.transaction.html#var-begin.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>begin!</span></div></a></li><li class="depth-2 branch"><a href="jdbc.transaction.html#var-commit.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>commit!</span></div></a></li><li class="depth-2"><a href="jdbc.transaction.html#var-rollback.21"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>rollback!</span></div></a></li><li class="depth-1"><a href="jdbc.transaction.html#var-set-rollback.21"><div class="inner"><span>set-rollback!</span></div></a></li><li class="depth-1"><a href="jdbc.transaction.html#var-unset-rollback.21"><div class="inner"><span>unset-rollback!</span></div></a></li><li class="depth-1"><a href="jdbc.transaction.html#var-with-transaction"><div class="inner"><span>with-transaction</span></div></a></li><li class="depth-1"><a href="jdbc.transaction.html#var-with-transaction-strategy"><div class="inner"><span>with-transaction-strategy</span></div></a></li><li class="depth-1"><a href="jdbc.transaction.html#var-wrap-transaction-strategy"><div class="inner"><span>wrap-transaction-strategy</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">jdbc.transaction</h2><div class="doc"><pre class="plaintext">Transactions support for clojure.jdbc
</pre></div><div class="public anchor" id="var-*default-tx-strategy*"><h3>*default-tx-strategy*</h3><h4 class="dynamic">dynamic</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L133">view source</a></div></div><div class="public anchor" id="var--.3EDefaultTransactionStrategy"><h3>-&gt;DefaultTransactionStrategy</h3><div class="usage"><code>(-&gt;DefaultTransactionStrategy)</code></div><div class="doc"><pre class="plaintext">Positional factory function for class jdbc.transaction.DefaultTransactionStrategy.
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L24">view source</a></div></div><div class="public anchor" id="var-call-in-transaction"><h3>call-in-transaction</h3><div class="usage"><code>(call-in-transaction conn func &amp; [{:keys [savepoints strategy], :or {savepoints true}, :as opts}])</code></div><div class="doc"><pre class="plaintext">Wrap function in one transaction.
This function accepts as a parameter a transaction strategy. If no one
is specified, `DefaultTransactionStrategy` is used.

With `DefaultTransactionStrategy`, if current connection is already in
transaction, it uses truly nested transactions for properly handle it.
The availability of this feature depends on database support for it.

Example:

(with-connection dbspec conn
  (call-in-transaction conn (fn [conn] (execute! conn &apos;DROP TABLE foo;&apos;))))

For more idiomatic code, you should use `with-transaction` macro.

Depending on transaction strategy you are using, this function can accept
additional parameters. The default transaction strategy exposes two additional
parameters:

- `:isolation-level` - set isolation level for this transaction
- `:read-only` - set current transaction to read only
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L135">view source</a></div></div><div class="public anchor" id="var-is-rollback-set.3F"><h3>is-rollback-set?</h3><div class="usage"><code>(is-rollback-set? conn)</code></div><div class="doc"><pre class="plaintext">Check if a current connection in one transaction
is marked for rollback.

This should be used in one transaction, in other case this
function always return false.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L122">view source</a></div></div><div class="public anchor" id="var-ITransactionStrategy"><h3>ITransactionStrategy</h3><h4 class="type">protocol</h4><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="members"><h4>members</h4><div class="inner"><div class="public anchor" id="var-begin.21"><h3>begin!</h3><div class="usage"><code>(begin! _ conn opts)</code></div><div class="doc"><pre class="plaintext">Starts a transaction and return a connection instance.
</pre></div></div><div class="public anchor" id="var-commit.21"><h3>commit!</h3><div class="usage"><code>(commit! _ conn opts)</code></div><div class="doc"><pre class="plaintext">Commits a transaction. Returns nil.
</pre></div></div><div class="public anchor" id="var-rollback.21"><h3>rollback!</h3><div class="usage"><code>(rollback! _ conn opts)</code></div><div class="doc"><pre class="plaintext">Rollbacks a transaction. Returns nil.
</pre></div></div></div></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L19">view source</a></div></div><div class="public anchor" id="var-set-rollback.21"><h3>set-rollback!</h3><div class="usage"><code>(set-rollback! conn)</code></div><div class="doc"><pre class="plaintext">Mark a current connection for rollback.

It ensures that on the end of the current transaction
instead of commit changes, rollback them.

This function should be used inside of a transaction
block, otherwise this function does nothing.

Example:

(with-transaction conn
  (make-some-queries-without-changes conn)
  (set-rollback! conn))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L95">view source</a></div></div><div class="public anchor" id="var-unset-rollback.21"><h3>unset-rollback!</h3><div class="usage"><code>(unset-rollback! conn)</code></div><div class="doc"><pre class="plaintext">Revert flag setted by `set-rollback!` function.
This function should be used inside of a transaction
block, otherwise this function does nothing.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L114">view source</a></div></div><div class="public anchor" id="var-with-transaction"><h3>with-transaction</h3><h4 class="type">macro</h4><div class="usage"><code>(with-transaction conn &amp; body)</code></div><div class="doc"><pre class="plaintext">Creates a context that evaluates in transaction (or nested transaction).
This is a more idiomatic way to execute some database operations in
atomic way.

Example:

(with-transaction conn
  (execute! conn &apos;DROP TABLE foo;&apos;)
  (execute! conn &apos;DROP TABLE bar;&apos;))

Also, you can pass additional options to transaction:

(with-transaction conn {:read-only true}
  (execute! conn &apos;DROP TABLE foo;&apos;)
  (execute! conn &apos;DROP TABLE bar;&apos;))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L183">view source</a></div></div><div class="public anchor" id="var-with-transaction-strategy"><h3>with-transaction-strategy</h3><h4 class="type">macro</h4><div class="usage"><code>(with-transaction-strategy conn strategy &amp; body)</code></div><div class="doc"><pre class="plaintext">Set some transaction strategy connection in the current context scope.
This method not uses thread-local dynamic variables and connection
preserves a transaction strategy throught threads.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L175">view source</a></div></div><div class="public anchor" id="var-wrap-transaction-strategy"><h3>wrap-transaction-strategy</h3><div class="usage"><code>(wrap-transaction-strategy conn strategy)</code></div><div class="doc"><pre class="plaintext">Simple helper function that associate a strategy
to a connection and return a new connection object
with wrapped stragy.

Example:

(let [conn (wrap-transaction-strategy simplecon (MyStrategy.))]
  (use-your-new-conn conn))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/transaction.clj#L82">view source</a></div></div></div></body></html>
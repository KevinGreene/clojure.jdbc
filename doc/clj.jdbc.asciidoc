clj.jdbc documentation
======================
Andrey Antukh, <niwi@niwi.be>
0.1.0, 2014-02-16

:toc:
:numbered:


Introduction
------------

_clj.jdbc_ is a library for low level, jdbc based database access.


link:api/index.html[Api reference documentation.]

Philosofy
~~~~~~~~~

Five most important rules:

- Beautiful is better than ugly.
- Explicit is better than implicit.
- Simple is better than complex.
- Complex is better than complicated.
- Readability counts.

All contributions to _clj.jdbc_ should keep these important rules in mind.

Project Maturity
----------------

_clj.jdbc_ is a young project and can have some bugs. Now, api is still stable
and should not experiment big backward incompatible changes.

Install
-------

This section covers a installation and requirements of _clj.jdbc_

Requirements
~~~~~~~~~~~~

_clj.jdbc_ is tested with these platforms:

- OpenJDK7
- OpenJDK6
- Oracle JDK7

Leiningen
~~~~~~~~~

The simplest way to use _clj.jdbc_ on clojure project, is including it on dependency
vector of your *_project.clj_* file:

._on project.clj_
[source,clojure]
----
[be.niwi/clj.jdbc "0.1.0-rc1"]
----

Gradle
~~~~~~

If you are using gradle, this is a dependency line for gradle dsl:

[source,groovy]
----
compile "be.niwi:clj.jdbc:0.1.0-rc1"
----

Maven
~~~~~

And for old school people, who are using a ugly xml files for configure everything,
this is a xml that you should put on dependency section on a maven config file:

.Repository entry.
[source,xml]
----
<repository>
    <id>clojars.org</id>
    <url>http://clojars.org/repo</url>
</repository>
----

.Dependency entry.
[source,xml]
----
<dependency>
  <groupId>be.niwi</groupId>
  <artifactId>clj.jdbc</artifactId>
  <version>0.1.0-rc1</version>
</dependency>
----

Get the Code
~~~~~~~~~~~~

_clj.jdbc_ is developed on GitHub, where the code is link:https://github.com/niwibe/clj.jdbc[always available].

You can either clone the public repository:

[source,text]
----
git clone https://github.com/niwibe/clj.jdbc.git
----


User guide
----------

Connecting to database
~~~~~~~~~~~~~~~~~~~~~~

Connection parameters
^^^^^^^^^^^^^^^^^^^^^

Usually, the documentation of any jvm language that explains JDBC always
supposes that the reader comes from Java and knowns JDBC well. This
documentation will not make the same mistake.

JDBC is the default Java abstraction/interface for SQL databases.  It's like
the Python DB-API and similar abstractions in other languages.  Clojure, as a
guest language on the jvm, benefits from having a good, well tested abstraction
like this.

*dbspec* is a simple Clojure way to define the database connection parameters
using plain native clojure hash-map, that are used to create a new database 
connection or create a new datasource (connection pool).

This is a default aspect of one dbspec definition:

[source,clojure]
----
{:classname "org.postgresql.Driver"
 :subprotocol "postgresql"
 :subname "//localhost:5432/dbname"
 :user "username"
 :password "password"}
----

Description of the parameters:

- `:classname` is a class location/route of JDBC driver. Each driver has one; in
  this example it is a path to a Postgresql JDBC driver.  This parameter can be
  omited and in that case it is automatically resolved from a predefined list
  using `:subprotocol` key.
- `:user` and `:password` can be ommited if they are empty.

dbspec has other formats which are parsed to the previously explained format.
As an example, you can pass a string containing a url with same data:

[source,clojure]
----
"postgresql://user:password@localhost:5432/dbname"
----


Creating a connection
^^^^^^^^^^^^^^^^^^^^^

In clj.jdbc, every function that interacts with a database requires explicitly
one connection instance as parameter. No dynamic vars are used for it.

In contrast to clojure.java.jdbc, clj.jdbc requires that the connections should
to be explicitly opened before any operation (you can't use dbspec map
as connection). For this purpose, clj.jdbc exposes two ways to create new connections:
`make-connection` function and the `with-connection` macro.

The `make-connection` function exposes a low level interface for creating a connection,
and delegates to user the connection resource management. A connection is not automatically
closed and is strongly recommended use of `with-open` macro for clear resource management.

NOTE: clj.jdbc does not use any global/thread-local state, and always try ensure immutability.

.Example using `make-connection` function
[source,clojure]
----
(let [conn (make-connection dbspec)]
  (do-something-with conn)
  (.close conn))
----

.Much better usage of `make-connection` function
[source,clojure]
----
(with-open [conn (make-connection dbspec)]
  (do-something-with conn))
----

However, the `with-connection` macro intends to be a high level abstraction and
works like `with-open` clojure macro. And this is an equivalent piece of code using 
`with-connection` macro:

[source,clojure]
----
(with-connection [conn dbspec]
  (do-something-with conn))
----


Execute database commands
~~~~~~~~~~~~~~~~~~~~~~~~~

clj.jdbc has many methods for executing database commands, like creating
tables, inserting data or simply executing stored procedures.


Execute raw sql statements
^^^^^^^^^^^^^^^^^^^^^^^^^^

The simplest way to execute a raw SQL is using the ``execute!`` function. It
receives a connection as the first parameter followed by variable list
of sql sentences:

[source,clojure]
----
(with-connection [conn dbspec]
  (execute! conn "CREATE TABLE foo (id serial, name text);"))
----


Execute parametrized SQL statements
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Raw SQL statements work well for creating tables and similar operations, but
when you need to insert some data, especially if the data comes from untrusted
sources, the ``execute!`` function is not adequate.

For this problem, clj.jdbc exposes `execute-prepared!` function. It
accepts parametrized SQL and a list of groups of parameters that allow
execute amount of same operations with distinct parameters in bulk.

.Execute a simple insert SQL statement:
[source,clojure]
----
(let [sql "INSERT INTO foo VALUES (?, ?);"]
  (execute-prepared! conn sql ["Foo", 2]))
----

.Execute inserts in bulk
[source,clojure]
----
(let [sql "INSERT INTO foo VALUES (?, ?);"]
  (execute-prepared! conn sql ["Foo", 2] ["Bar", 3]))

;; This should emit this sql:
;;   INSERT INTO foo VALUES ('Foo', 2);
;;   INSERT INTO foo VALUES ('Bar', 3);
----

Make queries
~~~~~~~~~~~~

As usual, clj.jdbc offers two ways to send queries to a database. But in this
section only will be explained the basic and the most usual way to make queries
using a `query` function.

`query` function, given a open connection and parametrized sql, executes it and returns
a evaluated result (as vector of records):

[source,clojure]
----
(let [sql    ["SELECT id, name FROM people WHERE age > ?", 2]
      result (query sql)]
  (doseq [row results]
  (println row))))
----

Parametrized sql can be:

- Vector with first element a sql string following with parameters
- Native string (sql query without parameters)
- Instance of `PreparedStatement`
- Instance of any type that implements `ISQLStatement` protocol.

[NOTE]
====
This method seems usefull en most of cases but can not works well with
queries that returns a lot of results. For this purpose, exists cursor
type queries that are explained on xref:cursor-queries[Advanced usage] section.
====


Transactions
~~~~~~~~~~~~

Getting start with transactions
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Managing transactions well is almost the most important thing when building an
application. Managing transactions implicitly, trusting your "web framework" 
to do it for you, is a very bad approach.

All transactions related functions are exposed on `jdbc.transaction` namespace
and if you need transactions, you should import it:

[source,clojure]
----
(require '[jdbc.transaction :as tx])
----

The most idiomatic way to wrap some code in transaction, is using `with-transaction`
macro:

(tx/with-transaction conn
  (do-thing-first conn)
  (do-thing-second conn))


[NOTE]
Contrary to what it seems, clj.jdbc not uses any dynamic thread-local vars for store
a transaction state for a connection. Instead of that, it overwrites lexical scope
value of conn with new connection that has a transactional state.

Low level transaction primitives
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Behind the scene of `with-transaction` macro, _clj.jdbc_ has uses `call-in-transaction`
function.

It, given a connection as first parameter and function that you want execute in a
transaction (that should accept connection as first parameter).

[source,clojure]
----
(tx/call-in-transaction conn (fn [conn] (do-something-with conn)))
----


[NOTE]
====
clj.jdbc in contrast to java.jdbc, handles well nested transactions. So making all
code wrapped in transaction block truly atomic independenty of transaction nesting.

If you want extend o change a default transaction strategy, see
xref:transaction-strategy[Transaction Strategy section].
====


Isolation Level
^^^^^^^^^^^^^^^

clj.jdbc by default does nothing with isolation level and keep it with default values. But
provides a simple way to set specific isolation level if is needed.

You can set custom isolation level on your dbspec map:

[source,clojure]
----
(def dbsoec {:subprotocol "h2"
             :subname "mem:"
             :isolation-level :serializable})
----

This is a list of supported options:

- `:read-commited` - Set read committed isolation level
- `:repeatable-read` - Set repeatable reads isolation level
- `:serializable` - Set serializable isolation level
- `:none` - Use this option to indicate to clj.jdbc to do nothing and keep default behavior.

You can read more about it on link:http://en.wikipedia.org/wiki/Isolation_(database_systems)[wikipedia].






Advanced usage
--------------

[[cursor-queries]]
Server Side Cursors
~~~~~~~~~~~~~~~~~~~

By default, most of jdbc drivers prefetches all results in memory that make totally useless use lazy
structures for fetching data. For solve this, some databases implements server side cursors that
avoids a prefetch all results of a query in memory.

If you have an extremely large result set to retrieve from your database, it is exactly what you need.

_clj.jdbc_, for this purpose, has `with-query` macro that uses server side cursors inside
and exposes a lazy seq of records (instead of full evaluated vector) in a created macro context:

[source,clojure]
----
(let [sql ["SELECT id, name FROM people;"]]
  (with-query conn sql results
    (doseq [row results]
      (println row))))
----

[NOTE]
====
`with-query` macro implicitly ensures that all of code executed insinde a created
context are executed on transaction or subtransaction. This is mandatory because a
server side cursors only works inside one transaction.
====


Low level query interface
~~~~~~~~~~~~~~~~~~~~~~~~~

All functions that executes queries, uses `make-query` function behind the scenes. Is a low
level interface for access to query functionality.

This function has distinct behavior in comparison with his high level siblings: it returns a
`jdbc.types.resultset.ResultSet` instance that works as clojure persistent map and contains 
these keys:

- `:stmt` key contains a statement instance used for make a query.
- `:rs` key contains a raw `java.sql.ResultSet` instance.
- `:data` key contains a real results as lazy-seq or vector depending on parameters.


.Example using `make-query` function
[source,clojure]
----
(let [sql    ["SELECT id, name FROM people WHERE age > ?", 2]
      result (make-query conn sql)]
  (doseq [row (:data result)]
    (println row))
  (.close result))
----

[NOTE]
====
You can see the api documentation to know more about it, but mainly it is
a container that mantains a reference  to the original java jdbc objects
which are used for executing a query.
====

[WARNING]
====
If you know how jdbc works, you should know that if you execute two queries and
the second is executed while the results of the first haven't been completely
consumed, the results of the first query are aborted.

`make-query` function should to be used with precaution.
====

[[connection-pool]]
Connection pool
~~~~~~~~~~~~~~~

All good database library should come with connection pool support. 

Java ecosystem comes with various connection pool implementations for jdbc and clj.jdbc
comes with c3p0 support.

For use a connection pool, you should conver your plain dbspec to datasource-dbspec using
helper functions that _clj.jdbc_ exposes:

[source,clojure]
----
(require '[jdbc.pool.c3p0 :as pool])
(def dbspec (pool/make-datasource-spec {:classname "org.postgresql.Driver"
                                        :subprotocol "postgresql"
                                        :subname "//localhost:5432/dbname"}))
;; dbspec now contains :datasource key with javax.sql.DataSource instance
;; instead of plain dbspec with connection parameters. This dbspec should be used
;; like a plain dbspec for open new connection.
----


[[transaction-strategy]]
Transaction strategy
~~~~~~~~~~~~~~~~~~~~

Transactions strategy on _clj.jdbc_ are implemented using protocols having default implementation explained
in previous sections. This approach, allows easy way to extend, customize or completely change a transaction 
strategy for your application.

If you want an other strategy, you should create a new type and implement `ITransactionStrategy` protocol.

.Simple example implementing dummy transaction strategy.
[source,clojure]
----
(defrecord DummyTransactionStrategy []
  tx/ITransactionStrategy
  (begin [_ conn opts] conn)
  (rollback [_ conn opts] conn)
  (commit [_ conn opts] conn))
----


For use it, _clj.jdbc_ exposes two ways:


.Using `with-transaction-strategy` macro
[source,clojure]
----
(with-connection [conn dbspec]
  (with-transaction-strategy conn (DummyTransactionStrategy.)
    (do-some-thing conn)))
----

.Using `wrap-transaction-strategy` function:
[source,clojure]
----
(with-open [conn (-> (make-connection dbspec)
                     (wrap-transaction-strategy (DummyTransactionStrategy.)))]
  (do-some-thing conn))
----

Extend sql types
~~~~~~~~~~~~~~~~

All related to type handling/conversion are exposed on `jdbc.types` namespace.

If you want extend some type/class for use it as jdbc parameter without explicit conversion
to sql compatible type, you should extend your type with `jdbc.types/ISQLType` protocol.

This is a sample example to extend a java String[] (string array) for pass it as parameter
to database field that correspons to postgresql text array on a database:

[source,clojure]
----
(extend-protocol ISQLType
  ;; Obtain a class for string array
  (class (into-array String []))

  (set-stmt-parameter! [this conn stmt index]
    (let [raw-conn        (:connection conn)
          prepared-value  (as-sql-type this conn)
          array           (.createArrayOf raw-conn "text" prepared-value)]
      (.setArray stmt index array)))

  (as-sql-type [this conn] this))
----

Now, you can pass a string array as jdbc parameter that is automaticlay converted
to sql array and assigned properly to prepared statement:

[source,clojure]
----
(with-connection [conn pg-dbspec]
  (execute! conn "CREATE TABLE arrayfoo (id integer, data text[]);")
  (let [mystringarray (into-array String ["foo" "bar"])]
    (execute-prepared! conn "INSERT INTO arrayfoo VALUES (?, ?);"
                       [1, mystringarray])))
----


clj.jdbc also exposes `jdbc.types/ISQLResultSetReadColumn` protocol that encapsulates
a backward conversions from sql types to user defined types.


How to contribute?
------------------

**clj.jdbc** unlike clojure and other clojure contrib libs, does not have much
restrictions for contribute. Just follow the following steps depending on the
situation:

**Bugfix**:

- Fork github repo.
- Fix a bug/typo on new branch.
- Make a pull-request to master.

**New feature**:

- Open new issue with new feature purpose.
- If it is accepted, follow same steps as "bugfix".


Faq
---

Why another jdbc wrapper?
~~~~~~~~~~~~~~~~~~~~~~~~~

This is a incomplete list of reasons:

- Connection management should be explicit. clj.jdbc has a clear differentiation
  between connection and dbspec without unnecessary nesting controls and with explicit
  resource management (using `with-open` or other specific macros for it, see the
  examples).
- clj.jdbc has full support for all the transactions api, with the ability to set the
  database isolation level and use nested transactions (savepoints).
  It creates a new transaction if no other transaction is active but,
  when invoked within the context of an already existing transaction, it creates a savepoint.
- clj.jdbc supports extend or overwrite a transaction management if a default
  behavior is not sufficient for you.
- clj.jdbc has native support for connection pools. 
- clj.jdbc has a simpler implementation than clojure.java.jdbc. It has no more
  complexity than necessary for each available function in public api. +
  +
  As an example:
  * clojure.java.jdbc has a lot boilerplate connection management around all functions
    that receives dbspec. It doesn't has well designed connection management. +
    +
    Ex: functions like `create!` can receive plain dbspec or a connection. If you are
    curious, take a look to `with-db-connection` implementation of clojure.java.jdbc
    and compare it with `with-connection` of clj.jdbc. You are going to give account of the
    hidden unnecesary complexity found on clojure.java.jdbc. +
    +
    clojure.java.jdbc has inconsistent connection management. In contrast, with clj.jdbc,
    a connection should be created explicitly befor use any other function that
    requires one connection.

    * clojure.java.jdbc has repeated transaction handling on each CRUD method
    (insert!, drop!, etc...). With clj.jdbc, if you want that some code to run in a
    transaction, you should wrap it in a transaction context explicitly, using the
    `with-transaction` macro (see the transactions section for more information).

- Much more documentation ;) (a project without documentation is a project that doesn't
  really exist).

clj.jdbc has better performance than java.jdbc?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Mostly **Yes**, _clj.jdbc_  by default has better performance than java.jdbc. You can
run the micro benchmark code on your environment with: `lein with-profile bench run`

On my environments, the result is:

[source,text]
----
[3/5.0.5]niwi@niwi:~/clj.jdbc> lein with-profile bench run
Simple query without connection overhead.
java.jdbc:
"Elapsed time: 673.890131 msecs"
clj.jdbc:
"Elapsed time: 450.329706 msecs"
Simple query with connection overhead.
java.jdbc:
"Elapsed time: 2490.233925 msecs"
clj.jdbc:
"Elapsed time: 2239.524395 msecs"
Simple query with transaction.
java.jdbc:
"Elapsed time: 532.151667 msecs"
clj.jdbc:
"Elapsed time: 475.982354 msecs"
----

Why clj.jdbc does not include dsl for working with sql as clojure.java.jdbc 0.3?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[quote, Douglas McIlroy, http://en.wikipedia.org/wiki/Douglas_McIlroy]
____
Write programs that do one thing and do it well.
____

clj.jdbc is a wrapper for Java JDBC interface, it doesn't intend provide helpers
for avoid sql usage. There already are a good number of DSLs for working with SQL.
clj.jdbc will not reinvent the wheel. +
One example of a good dsl for build sql: https://github.com/r0man/sqlingvo

This is a fork of clojure.java.jdbc?
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

No. Is just a alternative implementation.


License
-------

clj.jdbc are writen from scratch and is licensed under Apache 2.0 license:

----
Copyright 2013 Andrey Antukh <niwi@niwi.be>

Licensed under the Apache License, Version 2.0 (the "License")
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
----

You can see a full license on LICENSE file located on the root of the project
repo.

Additionaly, I want give thanks to `clojure.java.jdbc` developers for a good
initial work. Some intial ideas for clj.jdbc are taken from it.
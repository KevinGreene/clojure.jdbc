<!DOCTYPE html>
<html><head><meta charset="UTF-8"><link href="css/default.css" rel="stylesheet" type="text/css"><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>jdbc.core documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html">Clojure.jdbc 0.4.0-SNAPSHOT API documentation</a></h1></div><div class="sidebar" id="namespaces"><h3><a href="index.html"><span class="inner">Namespaces</span></a></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>jdbc</span></div></div></li><li class="depth-2 branch"><a href="jdbc.constants.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>constants</span></div></a></li><li class="depth-2 branch current"><a href="jdbc.core.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>core</span></div></a></li><li class="depth-2 branch"><a href="jdbc.impl.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>impl</span></div></a></li><li class="depth-2 branch"><a href="jdbc.meta.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>meta</span></div></a></li><li class="depth-2 branch"><a href="jdbc.proto.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>proto</span></div></a></li><li class="depth-2 branch"><a href="jdbc.transaction.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transaction</span></div></a></li><li class="depth-2 branch"><a href="jdbc.types.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>types</span></div></a></li><li class="depth-2"><a href="jdbc.util.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>util</span></div></a></li><li class="depth-3 branch"><a href="jdbc.util.exceptions.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>exceptions</span></div></a></li><li class="depth-3"><a href="jdbc.util.resultset.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>resultset</span></div></a></li></ul></div><div class="sidebar" id="vars"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="jdbc.core.html#var-connection"><div class="inner"><span>connection</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-cursor-.3Elazyseq"><div class="inner"><span>cursor-&gt;lazyseq</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-execute.21"><div class="inner"><span>execute!</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-execute-prepared.21"><div class="inner"><span>execute-prepared!</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-execute-statement.21"><div class="inner"><span>execute-statement!</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-get-returning-records"><div class="inner"><span>get-returning-records</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-is-prepared-statement.3F"><div class="inner"><span>is-prepared-statement?</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-lazy-query"><div class="inner"><span>lazy-query</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-make-connection"><div class="inner"><span>make-connection</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-prepared-statement"><div class="inner"><span>prepared-statement</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-query"><div class="inner"><span>query</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-query-first"><div class="inner"><span>query-first</span></div></a></li><li class="depth-1"><a href="jdbc.core.html#var-with-connection"><div class="inner"><span>with-connection</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h2 class="anchor" id="top">jdbc.core</h2><div class="doc"><pre class="plaintext">Alternative implementation of jdbc wrapper for clojure.
</pre></div><div class="public anchor" id="var-connection"><h3>connection</h3><div class="usage"><code>(connection dbspec)</code><code>(connection dbspec options)</code></div><div class="doc"><pre class="plaintext">Creates a connection to a database. As parameter accepts:

- dbspec map containing connection parameters
- dbspec map containing a datasource (deprecated)
- URI or string (interpreted as uri)
- DataSource instance

The dbspec map has this possible variants:

Classic approach:
  :subprotocol -&gt; (required) string that represents a vendor name (ex: postgresql)
  :subname -&gt; (required) string that represents a database name (ex: test)
  (many others options that are pased directly as driver parameters)

Pretty format:
  :vendor -&gt; (required) string that represents a vendor name (ex: postgresql)
  :name -&gt; (required) string that represents a database name (ex: test)
  :host -&gt; (optional) string that represents a database hostname (default: 127.0.0.1)
  :port -&gt; (optional) long number that represents a database port (default: driver default)
  (many others options that are pased directly as driver parameters)

URI or String format:
  vendor://user:password@host:post/dbname?param1=value

Additional options:
  :schema -&gt; string that represents a schema name (default: nil)
  :read-only -&gt; boolean for mark entire connection read only.
  :isolation-level -&gt; keyword that represents a isolation level (:none, :read-committed,
                      :read-uncommitted, :repeatable-read, :serializable)

Opions can be passed as part of dbspec map, or as optional second argument.
For more details, see documentation.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L49">view source</a></div></div><div class="public anchor" id="var-cursor-.3Elazyseq"><h3>cursor-&gt;lazyseq</h3><div class="usage"><code>(cursor-&gt;lazyseq cursor)</code><code>(cursor-&gt;lazyseq cursor options)</code></div><div class="doc"><pre class="plaintext">Execute a cursor query and return a lazyseq with results.
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L259">view source</a></div></div><div class="public anchor" id="var-execute.21"><h3>execute!</h3><div class="usage"><code>(execute! conn &amp; commands)</code></div><div class="doc"><pre class="plaintext">Run arbitrary number of raw sql commands such as: CREATE TABLE,
DROP TABLE, etc... If your want transactions, you can wrap this
call in transaction using `with-transaction` context block macro
that is available in  `jdbc.transaction` namespace.

Warning: not all database servers support ddl in transactions.

Examples:

  ;; Without transactions
  (with-connection dbspec conn
    (execute! conn &apos;CREATE TABLE foo (id serial, name text);&apos;))

  ;; In one transaction
  (with-connection dbspec conn
    (tx/with-transaction conn
      (execute! conn &apos;CREATE TABLE foo (id serial, name text);&apos;)))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L110">view source</a></div></div><div class="public anchor" id="var-execute-prepared.21"><h3>execute-prepared!</h3><div class="usage"><code>(execute-prepared! conn sql &amp; param-groups)</code></div><div class="doc"><pre class="plaintext">Given a active connection and sql (or prepared statement),
executes a query in a database. This differs from `execute!` function
with that this function allows pass parameters to query in a more safe
way and permit pass group of parrams enabling bulk operations.

After connection, sql/prepared statement and any number of group of
params you can pass options map (same as on `make-prepared-statement`
function).

Note: Some options are incompatible with self defined prepared
statement.

Example:

(with-connection dbspec conn
  (let [sql &quot;UPDATE TABLE foo SET x = ? WHERE y = ?;&quot;]
    (execute-prepared! conn sql [1 2] [2 3] [3 4])))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L156">view source</a></div></div><div class="public anchor" id="var-execute-statement.21"><h3>execute-statement!</h3><div class="usage"><code>(execute-statement! conn stmt param-groups)</code></div><div class="doc"><pre class="plaintext">Given a connection statement and paramgroups (can be empty)
execute the prepared statement and return results from it.

This is a low level interface and should be used with precaution. This
function is used internally for execue raw sql such as CREATE/DROP
table.

Status: Alpha - Implementation and name of this method can change on
next versions.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L28">view source</a></div></div><div class="public anchor" id="var-get-returning-records"><h3>get-returning-records</h3><div class="usage"><code>(get-returning-records conn stmt)</code></div><div class="doc"><pre class="plaintext">Given a executed prepared statement with expected returning
values. Return a vector of records of returning values.
Usually is a id of just inserted objects, but in other cases
can be complete objects.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L136">view source</a></div></div><div class="public anchor" id="var-is-prepared-statement.3F"><h3>is-prepared-statement?</h3><div class="usage"><code>(is-prepared-statement? obj)</code></div><div class="doc"><pre class="plaintext">Check if specified object is prepared statement.
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L145">view source</a></div></div><div class="public anchor" id="var-lazy-query"><h3>lazy-query</h3><div class="usage"><code>(lazy-query conn sqlvec)</code><code>(lazy-query conn sqlvec options)</code></div><div class="doc"><pre class="plaintext">Perform a lazy query using server side cursors if them are available.

This function returns a cursor instance. That cursor allows create
arbitrary number of lazyseqs.

Some databases requires that this funcion and lazyseq iteration
should be used in a transactoion context.

The returned cursor should be used with `with-open` clojure function
for proper resource handling.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L243">view source</a></div></div><div class="public anchor" id="var-make-connection"><h3>make-connection</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L108">view source</a></div></div><div class="public anchor" id="var-prepared-statement"><h3>prepared-statement</h3><div class="usage"><code>(prepared-statement conn sqlvec)</code><code>(prepared-statement conn sqlvec options)</code></div><div class="doc"><pre class="plaintext">Given a string or parametrized sql in sqlvec format
return an instance of prepared statement.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L150">view source</a></div></div><div class="public anchor" id="var-query"><h3>query</h3><div class="usage"><code>(query conn sqlvec)</code><code>(query conn sqlvec {:keys [lazy], :or {lazy false}, :as options})</code></div><div class="doc"><pre class="plaintext">Perform a simple sql query and return a evaluated result as vector.

`sqlvec` parameter can be: parametrized sql (vector format), plain sql
(simple sql string) or prepared statement instance.

Example using parametrized sql:

  (doseq [row (query conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (println row))

Example using plain sql (without parameters):

  (doseq [row (query conn &quot;SELECT version();&quot;)]
    (println row))

Example using extern prepared statement:

  (let [stmt (make-prepared-statement conn [&quot;SELECT foo FROM bar WHERE id = ?&quot; 1])]
    (doseq [row (query conn stmt)]
      (println row)))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L210">view source</a></div></div><div class="public anchor" id="var-query-first"><h3>query-first</h3><div class="usage"></div><div class="doc"><pre class="plaintext">Perform a simple sql query and return the first result. It accepts the
same arguments as the `query` function.</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L238">view source</a></div></div><div class="public anchor" id="var-with-connection"><h3>with-connection</h3><h4 class="type">macro</h4><div class="usage"><code>(with-connection dbspec &amp; body)</code></div><div class="doc"><pre class="plaintext">Given database connection paramers (dbspec), creates
a context with new connection to database that are closed
at end of code block.

If dbspec has datasource (connection pool), instead of create
a new connection, get it from connection pool and release it
at the end.

Example:

  (with-connection [conn dbspec]
    (do-somethin-with-connection conn))

Deprecated but yet working example (this behavior should be
removed on 1.1 version):

  (with-connection dbspec conn
    (do-something-with conn))
</pre></div><div class="src-link"><a href="http://github.com/niwibe/clojure.jdbc/blob/master/src/jdbc/core.clj#L265">view source</a></div></div></div></body></html>